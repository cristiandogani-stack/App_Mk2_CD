{% extends 'base.html' %}

{#
  Detailed bill of materials for a single product.

  This page displays the hierarchical list of assemblies, parts and
  commercial components that constitute a specific product.  A search
  field above the table allows filtering components by code, description
  or category.  The table headers match those used throughout the
  inventory module.  Rows are rendered inside a collapsible tree so
  users can expand or collapse assemblies to navigate the BOM.
#}

{% block title %}Magazzino ‚Äì {{ product.name }}{% endblock %}

{% block content %}
<section class="section">
  {# Back button to return to the previous page.  Uses the HTTP referrer if
     available, falling back to the warehouse product overview.  This restores
     the natural navigation flow when selecting a product from the warehouse. #}
  {# Always return to the inventory index rather than relying on the HTTP referrer,
     which may point to the add_stock route after loading stock. #}
  <a href="{{ url_for('inventory.index') }}" class="btn ghost small" style="margin-bottom:8px;">‚Üê Indietro</a>
  <h2 class="section-title">Magazzino: {{ product.name }}</h2>
  {# Tab navigation across product views.  Use links rather than buttons so
     each tab navigates to a dedicated view.  The active tab is determined
     by the ``active_tab`` parameter passed from the view. #}
  <div class="tab-links" style="display:flex; gap:8px; margin-bottom:20px; flex-wrap:wrap;">
    {# Removed "Prodotto" tab: only specialised views remain. #}
    <a href="{{ url_for('inventory.product_assemblies', product_id=product.id) }}"
       class="btn small{{ ' primary' if active_tab == 'assemblies' else ' ghost' }}">Assiemi</a>
    <a href="{{ url_for('inventory.product_parts', product_id=product.id) }}"
       class="btn small{{ ' primary' if active_tab == 'parts' else ' ghost' }}">Parti</a>
    <a href="{{ url_for('inventory.product_commercial', product_id=product.id) }}"
       class="btn small{{ ' primary' if active_tab == 'commercial' else ' ghost' }}">Commerciali</a>
    {# Archive tabs: separate component and assembly archives. #}
    <a href="{{ url_for('inventory.product_archive_view', product_id=product.id) }}"
       class="btn small{{ ' primary' if active_tab == 'archive' else ' ghost' }}">Archivio&nbsp;componenti</a>
    <a href="{{ url_for('inventory.product_archive_assemblies_view', product_id=product.id) }}"
       class="btn small{{ ' primary' if active_tab == 'archive_assiemi' else ' ghost' }}">Archivio&nbsp;assiemi</a>
  </div>

  {# Search bar and "Esplodi tutto" button on the same row.  The container uses flexbox
     to align items center and evenly space them.  This places the toggle button at
     the same height as the component search, centered within the page. #}
  <div style="margin-bottom:12px; display:flex; justify-content:center; align-items:center; flex-wrap:wrap; gap:8px;">
    <input type="text" id="component-search" class="input" placeholder="Cerca componenti..." style="width:100%; max-width:400px; padding:8px; border-radius:8px; border:1px solid var(--glass-stroke);">
    <button id="toggle-all" type="button" class="btn small ghost">Esplodi&nbsp;tutto</button>
  </div>

  {#
    Provide a top‚Äëlevel booking action for the finished product.

    Users expressed the need to reserve a complete product directly from
    the product detail page in the warehouse.  Previously the Prenota
    action was only available from the product overview or on individual
    components.  This button calls the same ``prenota`` helper used for
    component reservations but overrides the ``boxType`` to ``PRODOTTO``
    and the component code to the product name.  When clicked the
    operator is prompted for the quantity to reserve, a production
    box is created via the API and the browser navigates to the
    production box detail page where the guided build interface is
    available.  The button is visually separated from the search bar
    and toggle controls and appears only once per product.
  #}
  {# Removed top-level Prenota prodotto button.  Finished products are
     reserved via dedicated production workflows outside the per-product
     views. #}

  {# Table header #}
  <div class="component-header">
    <div class="component-row">
      <div class="col-number">#</div>
      <div class="col-image">Img</div>
      <div class="col-code">Codice</div>
      <div class="col-desc">Descrizione</div>
      {# Added revision column to align with other warehouse views and the component grid (eight columns).
         Without this column the table header would misalign with the component-row definition in styles.css.
         The revision column displays the human‚Äëreadable revision label (e.g. Rev.A) or a dash when none is set. #}
      <div class="col-revision">Revisione</div>
      <div class="col-category">Categoria</div>
      <div class="col-qty">Stock</div>
      <div class="col-actions">Azioni</div>
    </div>
  </div>
  <div class="component-tree">
    {# Recursive macro to render a structure node.  Derived from
       inventory/products.html and product detail page. #}
    {% macro render_node(node) %}
      {# Annotate each node with its category to enable category filtering via JavaScript. #}
      <details id="part-{{ node.structure.id }}" class="component-node"
               data-category="{% if node.structure.flag_assembly %}assembly{% elif node.structure.flag_commercial %}commercial{% else %}part{% endif %}"
               {% if not node.children %}data-leaf="true"{% endif %}>
        <summary>
          <div class="component-row">
            <div class="col-number">{{ node.number }}</div>
            <div class="col-image">
              {# Display the image associated with the ProductComponent if available.  Many users upload images to the component rather than the structure.  If no component image exists, fall back to the structure image; if neither exists, show a placeholder. #}
              {% if node.component and node.component.image_filename %}
                <img loading="lazy" src="{{ url_for('static', filename='uploads/' + node.component.image_filename) }}" alt="{{ node.structure.name }}">
              {% elif node.structure.image_filename %}
                <img loading="lazy" src="{{ url_for('static', filename='uploads/' + node.structure.image_filename) }}" alt="{{ node.structure.name }}">
              {% else %}
                <img loading="lazy" src="{{ url_for('static', filename='img/gear.svg') }}" alt="{{ node.structure.name }}" style="max-width:100%; max-height:80px; object-fit:contain; filter: invert(1); opacity:0.7;">
              {% endif %}
            </div>
            <div class="col-code">{{ node.structure.name }}</div>
            <div class="col-desc">
              {#
                Render the structure description for every node.  Assemblies
                previously displayed the hard‚Äëcoded label "Assieme" here,
                which obscured their actual description.  By unifying the
                logic with parts and commercial items we allow operators to
                read the descriptive text of each assembly.  If a
                description is missing we show a dash.  The category
                column still labels assemblies separately.
              #}
              {{ node.structure.description or '‚Äî' }}
            </div>
            {# Revision column: show the structure revision label when defined.
               Including this column ensures the row aligns with the eight-column
               component-row grid used throughout the warehouse module.  When no
               revision is set the revision_label property returns an empty string. #}
            <div class="col-revision">{{ node.structure.revision_label }}</div>
            <div class="col-category">
              {% if node.structure.flag_assembly %}Assieme{% elif node.structure.flag_commercial %}Commerciale{% else %}Parte{% endif %}
            </div>
              <div class="col-qty">{{ (node.structure.quantity_in_stock or 0)|int }}</div>
              <div class="col-actions" style="position:relative;">
                {#
                  For assemblies show a build button rather than reservation.
                  Display a green or red indicator with the number of assemblies that
                  can be built from current stock.  Disable the button when
                  zero units are buildable.  For non‚Äëassemblies show the
                  standard Prenota/Apri actions.
                #}
                {% if node.structure.flag_assembly %}
                  {# Determine availability: use available_qty when defined to account for assemblies already reserved in production boxes.
                     Fall back to complete_qty if available_qty is not set. #}
                  {% set avail = node.available_qty if node.available_qty is not none else node.complete_qty %}
                  {# Position the semaphore absolutely in the top right corner.  Because the container is relative, the
                     absolute positioning will not affect the flex layout of the buttons. #}
                  {% if avail and avail > 0 %}
                    <span style="position:absolute; top:0; right:0; color:#10b981; font-weight:600;">
                      üü¢ {{ avail }}
                    </span>
                  {% else %}
                    <span style="position:absolute; top:0; right:0; color:#ef4444; font-weight:600;">
                      üî¥ 0
                    </span>
                  {% endif %}
                  {# Show action buttons inline.  The parent .col-actions has display:flex and align-items:center set in the CSS, so
                     the buttons will be vertically centered automatically.  Use a gap to separate them. #}
                  {% if avail and avail > 0 %}
                    <a href="javascript:void(0);" class="btn primary small" onclick="costruisciAssembly('{{ node.structure.name }}', {{ avail }})" style="margin-right:4px;">Costruisci</a>
                  {% else %}
                    <a class="btn ghost small" style="pointer-events:none; opacity:0.5; margin-right:4px;">Costruisci</a>
                  {% endif %}
                  <a href="javascript:void(0);" class="btn ghost small" onclick='apri({{ product.id }}, {{ node.structure.name|tojson }})'>Apri</a>
                {% else %}
                  {# For non-assembly components, pass overrides to prenota so that
                     the DataMatrix reflects the specific component rather than
                     the root of the product.  Determine the box type from
                     the structure flags (commercial vs part) and use the
                     structure name as the component code. #}
                  <button class="btn primary small" type="button"
                          onclick='prenota({{ product.id }}, "{{ 'COMMERCIALE' if node.structure.flag_commercial else 'PARTE' }}", {{ node.structure.name|tojson }})' style="margin-right:4px;">Prenota</button>
                  {# Pass the structure name to the apri function so the modal shows only loaded items for this component #}
                  <button class="btn ghost small" type="button"
                          onclick='apri({{ product.id }}, {{ node.structure.name|tojson }})'>Apri</button>
                {% endif %}
              </div>
          </div>
        </summary>
        {% if node.children %}
        <div class="children">
          {% for child in node.children %}
            {{ render_node(child) }}
          {% endfor %}
        </div>
        {% endif %}
      </details>
    {% endmacro %}

    {# Render the root nodes of the product's structure tree #}
    {% for node in rows_tree %}
      {{ render_node(node) }}
    {% endfor %}
  </div>

  <script>
  // Simple recursive filter for the component tree.  Hides nodes that do
  // not match the search query.  When a parent has no matching
  // descendants it is also hidden.  Utilises :scope to restrict
  // selectors to the current node.
  document.addEventListener('DOMContentLoaded', function(){
    const input = document.getElementById('component-search');
    if (!input) return;
    input.addEventListener('input', () => {
      const query = input.value.toLowerCase().trim();
      const productNodes = document.querySelectorAll('.component-tree > details');
      productNodes.forEach(node => {
        filterDetail(node, query);
      });
    });

    function filterDetail(detailEl, query) {
      // Determine if this node or any of its descendants match
      let match = false;
      // Check the text content of the summary row
      const summaryRow = detailEl.querySelector(':scope > summary .component-row');
      if (summaryRow) {
        const text = summaryRow.textContent.toLowerCase();
        if (text.includes(query)) {
          match = true;
        }
      }
      // Recurse into children container
      const childrenContainer = detailEl.querySelector(':scope > .children');
      if (childrenContainer) {
        const childDetails = Array.from(childrenContainer.children).filter(e => e.tagName.toLowerCase() === 'details');
        let anyChildMatch = false;
        childDetails.forEach(child => {
          const childMatch = filterDetail(child, query);
          if (childMatch) anyChildMatch = true;
        });
        match = match || anyChildMatch;
      }
      // Show or hide this detail element
      detailEl.style.display = match || query === '' ? '' : 'none';
      return match;
    }
  });

  </script>

  {# Toggle all script.  When the toggle button is clicked, determine whether all nodes are currently expanded
     (i.e. have the "open" attribute).  If so, collapse them by removing the attribute; otherwise expand all by
     adding the attribute.  The button label updates accordingly. #}
  <script>
  document.addEventListener('DOMContentLoaded', function(){
    const toggleBtn = document.getElementById('toggle-all');
    if (!toggleBtn) return;
    toggleBtn.addEventListener('click', function(){
      const detailsNodes = document.querySelectorAll('.component-tree details');
      // Determine if every details element is open
      const allOpen = Array.from(detailsNodes).every(d => d.hasAttribute('open'));
      detailsNodes.forEach(d => {
        if (allOpen) {
          d.removeAttribute('open');
        } else {
          d.setAttribute('open', '');
        }
      });
      this.textContent = allOpen ? 'Esplodi tutto' : 'Comprimi tutto';
    });
  });
  </script>

  {# Global variables and helper functions for the reservation workflow #}
  <script>
    document.addEventListener('DOMContentLoaded', function(){
      // Expose the current product id on the window so it can be accessed from inline handlers
      window.currentProductId = {{ product.id }};
    });

    function redirectToProductionOverview(boxType, boxId) {
      const params = new URLSearchParams();
      const tab = (boxType || '').toString().trim().toUpperCase();
      if (tab) {
        params.set('tab', tab);
      }
      if (boxId) {
        params.set('box', boxId);
      }
      let url = '/production/';
      const query = params.toString();
      if (query) {
        url += `?${query}`;
      }
      if (boxId) {
        url += `#box-${boxId}`;
      }
      window.location.href = url;
    }

    /**
     * Prompt the user to enter a quantity and create a reservation via the API.
     * Optional parameters allow overriding the default box type and
     * component code so that bookings from the product detail page can
     * correctly reserve individual parts or commercial components.
     *
     * @param {number} productId - The id of the product associated with the reservation.
     * @param {string} [boxType] - The type of box (PARTE, ASSIEME, COMMERCIALE).
     * @param {string} [componentCode] - The name of the component to encode in the DataMatrix.
     */
    function prenota(productId, boxType, componentCode) {
      const qtyStr = prompt('Quantit√† da prenotare', '1');
      if (qtyStr === null) return; // cancelled
      const qty = parseInt(qtyStr, 10);
      if (!qty || qty <= 0) {
        alert('Quantit√† non valida');
        return;
      }
      const payload = { productId: productId, quantity: qty, note: '' };
      if (boxType) payload.boxType = boxType;
      if (componentCode) payload.componentCode = componentCode;
      fetch('/api/reservations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      })
        .then(res => {
          if (!res.ok) throw new Error('Errore nella creazione della prenotazione');
          return res.json();
        })
        .then(data => {
          const codes = data.items.map(item => item.datamatrix).join(', ');
          alert('Prenotazione creata.\nBox: ' + data.productionBoxId + '\nCodici: ' + codes);
          if (data.productionBoxId) {
            const targetType = data.boxType || payload.boxType || 'PARTE';
            redirectToProductionOverview(targetType, data.productionBoxId);
          }
        })
        .catch(err => {
          alert('Si √® verificato un errore: ' + err.message);
          console.error(err);
        });
    }

    /**
     * Navigate to the list of loaded components for the given product.
     *
     * @param {number} productId - The product id.
     */
    /*
     * Apri: mostra la lista dei componenti caricati per un dato prodotto.
     * Se viene fornito un codice componente, filtra i risultati mostrando
     * solo i codici DataMatrix con un campo P= corrispondente a quel nome.
     */
    function apri(productId, componentCode) {
      // Fetch loaded items via API and display in a modal instead of navigating
      fetch('/api/products/' + productId + '/loaded')
        .then(res => {
          if (!res.ok) throw new Error('Errore nella chiamata API');
          return res.json();
        })
        .then(data => {
          const items = data.items || [];
          // Optionally filter items by component code by inspecting the DataMatrix P= field
          let filtered = items;
          if (componentCode) {
            const code = componentCode.toString();
            filtered = items.filter(it => {
              const parts = it.datamatrix ? it.datamatrix.split('|') : [];
              for (const p of parts) {
                if (p.startsWith('P=')) {
                  return p.slice(2) === code;
                }
              }
              return false;
            });
          }
          const modal = document.getElementById('loadedModal');
          const content = document.getElementById('loadedItemsContent');
          let html = '';
          if (filtered.length === 0) {
            html = '<p class="muted">Nessun componente caricato per questo elemento.</p>';
          } else {
            html += '<table class="table table-compact">';
            html += '<thead><tr><th>#</th><th>DataMatrix</th><th>Box</th><th>Stato</th></tr></thead><tbody>';
            filtered.forEach((it, idx) => {
              html += '<tr>';
              html += '<td>' + (idx + 1) + '</td>';
              html += '<td style="font-family:monospace;">' + it.datamatrix + '</td>';
              html += '<td>' + (it.boxId || '‚Äî') + '</td>';
              html += '<td>' + (it.status || 'COMPLETATO') + '</td>';
              html += '</tr>';
            });
            html += '</tbody></table>';
          }
          content.innerHTML = html;
          modal.style.display = 'block';
        })
        .catch(err => {
          alert('Si √® verificato un errore: ' + err.message);
          console.error(err);
        });
    }

    // Close the loaded items modal
    function closeLoadedModal() {
      const modal = document.getElementById('loadedModal');
      if (modal) modal.style.display = 'none';
    }

    /**
     * Reserve a number of assemblies for production and create a production box.
     * Prompts the user for a quantity up to maxQty, then calls the
     * reservations API with an override to ensure the box is treated as
     * an assembly.  On success, redirects to the production box page.
     *
     * @param {string} assemblyName - The component name of the assembly.
     * @param {number} maxQty - The maximum number of units that can be built.
     */
    function costruisciAssembly(assemblyName, maxQty) {
      if (!maxQty || maxQty <= 0) {
        alert('Nessuna unit√† costruibile disponibile.');
        return;
      }
      const qtyStr = prompt('Quantit√† da costruire (max ' + maxQty + ')', '1');
      if (qtyStr === null) return;
      const qty = parseInt(qtyStr, 10);
      if (!qty || qty <= 0 || qty > maxQty) {
        alert('Quantit√† non valida.');
        return;
      }
      fetch('/api/reservations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          productId: window.currentProductId,
          quantity: qty,
          note: '',
          boxType: 'ASSIEME',
          componentCode: assemblyName
        })
      })
        .then(res => {
          if (!res.ok) throw new Error('Errore nella creazione della prenotazione');
          return res.json();
        })
        .then(data => {
          const codes = data.items.map(i => i.datamatrix).join(', ');
          alert('Prenotazione creata.\nBox: ' + data.productionBoxId + '\nCodici: ' + codes);
          if (data.productionBoxId) {
            redirectToProductionOverview(data.boxType || 'ASSIEME', data.productionBoxId);
          }
        })
        .catch(err => {
          alert('Si √® verificato un errore: ' + err.message);
          console.error(err);
        });
    }
  </script>

  {# Modal for displaying loaded components #}
  <div id="loadedModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1000; overflow:auto;">
    <div style="background:var(--glass-bg); margin:60px auto; padding:20px; border-radius:12px; max-width:600px; width:90%; position:relative;">
      <h3 style="margin-top:0;">Componenti caricati</h3>
      <div id="loadedItemsContent"></div>
      <div style="text-align:right; margin-top:12px;">
        <button class="btn primary small" onclick="closeLoadedModal()">Chiudi</button>
      </div>
    </div>
  </div>

  {# The category filter script has been removed in favour of dedicated pages
     for assemblies, parts and commercial components.  Filtering on the
     product detail page is now limited to the text search above. #}
</section>
{% endblock %}