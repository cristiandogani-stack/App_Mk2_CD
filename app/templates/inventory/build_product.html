{% extends 'base.html' %}

{#
  Guided procedure for constructing a finished product.

  This template mirrors the build_assembly interface: it lists all
  immediate child products (parts, assemblies or commercial items)
  required to assemble the selected product, shows their current stock
  levels, displays any existing documentation for both the product and
  its children and requires the operator to upload a compiled version
  for every existing document.  Each child card includes an "Associa"
  button that prompts for a DataMatrix scan; successful scans link
  the scanned component to the current build via the API.  A traffic
  light indicator at the top reflects readiness: it turns green only
  when all child components are in stock, each has been associated the
  required number of times and all required document uploads have a
  file selected.  The build button is enabled only when the indicator
  is green.  Operators may cancel the operation via the back link or
  by clicking "Annulla".
#}

{% block title %}Costruisci {{ product.name }} â€“ Magazzino{% endblock %}

{#
  When this build page is loaded inside an embedded modal (triggered via
  the ``embedded`` query parameter), hide the application header and
  navigation to minimise distractions and provide a clean popup.  Also
  intercept form submission: ask for confirmation before proceeding and
  schedule the closure of the modal after a short delay so that the
  backend has time to process the request.  These behaviours mirror
  those implemented in the assembly build template.
#}
{% if embedded %}
<style>
  /* Hide header and mobile navigation completely when embedded */
  .app-header, .nav-mobile { display:none !important; }
  /* Hide the back link at the top of the build page */
  .back-link { display:none !important; }
</style>
<script>
// Embedded mode submission handling
document.addEventListener('DOMContentLoaded', function(){
  const form = document.querySelector('form');
  if (!form) return;
  form.addEventListener('submit', function(e){
    // Prompt the user before submitting
    const ok = confirm('Confermare la costruzione del prodotto?');
    if (!ok) {
      e.preventDefault();
      return;
    }
    // After submission, close the modal and refresh the parent page
    setTimeout(function(){
      if (window.parent && window.parent !== window) {
        try {
          if (typeof window.parent.handleEmbeddedBuildComplete === 'function') {
            window.parent.handleEmbeddedBuildComplete('success');
          } else {
            const parentDoc = window.parent.document;
            const modal = parentDoc.getElementById('buildModal');
            const iframe = parentDoc.getElementById('buildFrame');
            if (iframe) iframe.src = '';
            if (modal) modal.style.display = 'none';
            window.parent.location.reload();
          }
        } catch(err) {
          console.error(err);
        }
      }
    }, 1000);
  });
});
</script>
{% endif %}

{% block content %}
<section class="section workflow-section">
  <div class="glass workflow-container">
    <div class="workflow-hero">
      <div class="workflow-hero-main">
        <div class="workflow-thumb">
          {% set prod_image = product.display_image_filename or product.image_filename %}
          {% if prod_image %}
            <img loading="lazy" src="{{ url_for('static', filename='uploads/' + prod_image) }}" alt="{{ product.name }}">
          {% else %}
            <img loading="lazy" src="{{ url_for('static', filename='img/gear.svg') }}" alt="{{ product.name }}" style="filter: invert(1); opacity:0.7;">
          {% endif %}
        </div>
        <div class="workflow-hero-copy">
          <span class="workflow-eyebrow">Costruzione prodotto</span>
          <h1 class="workflow-title">{{ product.name }}</h1>
          {% if product.description %}
            <p class="workflow-subtitle">{{ product.description }}</p>
          {% endif %}
        </div>
      </div>
      <div class="workflow-hero-actions">
        <span id="product-status" class="workflow-indicator" title="Stato lavorazione">{{ 'ðŸŸ¢ Pronto' if ready_parts and docs_ready and assoc_ready else 'ðŸ”´ In attesa' }}</span>
        <a href="{{ back_url or url_for('inventory.product_detail', product_id=product.id) }}" class="btn ghost small back-link">Indietro</a>
      </div>
    </div>
    {% if children|length == 0 %}
      <div class="workflow-body">
        <p class="muted" style="margin:0;">Nessun BOM definito per questo prodotto.</p>
      </div>
    {% else %}
      <form method="post" enctype="multipart/form-data" class="workflow-form form">
        <input type="hidden" name="back_url" value="{{ back_url or url_for('inventory.product_detail', product_id=product.id) }}">
        {% if csrf_token %}
          <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
        {% endif %}
        {% set prod_docs = doc_map.get(product.id) %}
        <div class="workflow-body">
          <div class="workflow-main">
            <div class="workflow-block">
              <h4>Associa i componenti richiesti</h4>
              <p class="muted" style="margin:0 0 12px;">Scansiona ogni componente fino al totale richiesto e assicurati che tutte le quantitÃ  siano disponibili.</p>
              <div class="grid grid-2 workflow-association-grid">
                {% for c in children %}
                  {% set child = c.child %}
                  <div class="card glass workflow-association-card">
                    <div class="workflow-association-thumb">
                      {% if child.display_image_filename %}
                        <img loading="lazy" src="{{ url_for('static', filename='uploads/' + child.display_image_filename) }}" alt="{{ child.name }}">
                      {% elif child.image_filename %}
                        <img loading="lazy" src="{{ url_for('static', filename='uploads/' + child.image_filename) }}" alt="{{ child.name }}">
                      {% else %}
                        <img loading="lazy" src="{{ url_for('static', filename='img/gear.svg') }}" alt="{{ child.name }}" style="filter: invert(1); opacity:0.7;">
                      {% endif %}
                    </div>
                    <h4 class="workflow-association-title">{{ child.name }}</h4>
                    <p class="workflow-association-meta">Richiesti: {{ required_quantities.get(child.id, 1) }}</p>
                    <p class="workflow-association-meta">Associati: {{ associated_counts.get(child.id, 0) }}</p>
                    <p class="workflow-association-meta">Disponibili: {{ (child.quantity_in_stock or 0)|int }}</p>
                    <button type="button"
                            class="btn small primary associate"
                            data-part-id="{{ child.id }}"
                            data-part-name="{{ child.name }}"
                            data-required="{{ required_quantities.get(child.id, 1) }}"
                            data-associated="{{ associated_counts.get(child.id, 0) }}"
                            {% if (not assembly_code) or (associated_counts.get(child.id, 0) >= required_quantities.get(child.id, 1)) %}disabled{% endif %}>Associa</button>
                  </div>
                {% endfor %}
              </div>
            </div>
          </div>
          <aside class="workflow-side">
            <div class="workflow-block">
              <h4>Documenti prodotto</h4>
              {% if prod_docs %}
                <div class="document-section">
                  {# Iterate once per document category.  For each category, list all existing documents
                     with download links, then show a single file input for uploading the compiled
                     version.  This prevents duplicate file inputs when multiple source documents
                     exist in the same category. #}
                  {% for folder_key, docs in prod_docs.items() %}
                    {% if docs|length > 0 %}
                    <div class="document-card">
                      <div class="document-card-header">
                        <span class="document-card-title">{{ doc_label_map.get(folder_key, folder_key) }}</span>
                        <div class="document-card-meta">
                          <div class="document-downloads">
                            {% for doc in docs %}
                            <div class="document-downloads-row">
                              <span style="font-size:14px;">{{ doc.display_name }}</span>
                              {% if doc.url %}
                                <a href="{{ doc.url }}" target="_blank" class="btn ghost small" style="white-space:nowrap;">Scarica</a>
                              {% else %}
                                <span class="muted" style="white-space:nowrap;">â€”</span>
                              {% endif %}
                            </div>
                            {% endfor %}
                          </div>
                        </div>
                      </div>
                      <div class="document-card-body">
                        <input type="file" name="upload_{{ product.id }}_{{ folder_key }}_0" required>
                        <span class="file-name document-file-name"></span>
                      </div>
                    </div>
                    {% endif %}
                  {% endfor %}
                </div>
              {% else %}
                <p class="muted" style="margin:0;">Nessuna documentazione richiesta per il prodotto.</p>
              {% endif %}
            </div>
          </aside>
        </div>
        <div class="workflow-footer">
          <a href="{{ back_url or url_for('inventory.product_detail', product_id=product.id) }}" class="btn ghost">Annulla</a>
          <button type="submit" class="btn primary" {% if not ready_all %}disabled{% endif %}>Costruisci</button>
        </div>
      </form>
    {% endif %}
  </div>
</section>
<script>
// Dynamic update of the traffic light and build button.  This script
// monitors all file inputs and recomputes readiness whenever a file
// changes.  It also references server-provided readiness flags for
// parts and associations.  When all conditions are satisfied the
// traffic light turns green and the build button is enabled.
document.addEventListener('DOMContentLoaded', function() {
  const form = document.querySelector('form');
  if (!form) return;
  const fileInputs = form.querySelectorAll('input[type="file"]');
  const semSpan = document.getElementById('product-status');
  const buildBtn = form.querySelector('button[type="submit"]');
  const readyParts = {{ ready_parts | tojson | safe }};
  const assocReady = {{ assoc_ready | tojson | safe }};
  let docsReadyInit = {{ docs_ready | tojson | safe }};
  function updateReady() {
    let docsOk = docsReadyInit;
    // When docs are not initially ready, ensure every file input has at least one file selected
    if (!docsOk) {
      docsOk = true;
      fileInputs.forEach(function(inp) {
        if (!inp.files || inp.files.length === 0) {
          docsOk = false;
        }
      });
    }
    const allReady = docsOk && readyParts && assocReady;
    if (semSpan) {
      semSpan.textContent = allReady ? 'ðŸŸ¢ Pronto' : 'ðŸ”´ In attesa';
    }
    if (buildBtn) {
      buildBtn.disabled = !allReady;
    }
  }
  fileInputs.forEach(function(inp) {
    inp.addEventListener('change', updateReady);
  });
  // Initial evaluation
  updateReady();
});
</script>
<script>
// Association workflow for linking scanned components to this product build.
// Each "Associa" button prompts for a DataMatrix code.  The scanned
// code and the assembly_code of this product are sent to the API.
// On success the page reloads to reflect updated association counts.
document.addEventListener('DOMContentLoaded', function() {
  const assemblyCode = {{ assembly_code | tojson | safe }};
  const associateButtons = document.querySelectorAll('.associate');
  associateButtons.forEach(function(btn) {
    btn.addEventListener('click', function() {
      if (!assemblyCode) {
        alert('Nessun codice prodotto disponibile. Apri la costruzione da una prenotazione con scatola.');
        return;
      }
      const partName = this.dataset.partName || '';
      const required = parseInt(this.dataset.required || '1');
      const associated = parseInt(this.dataset.associated || '0');
      if (associated >= required) {
        // Do not allow additional associations when requirement is met
        return;
      }
      const scanned = prompt('Scansiona il datamatrix del componente ' + partName + ':');
      if (!scanned) {
        return;
      }
      const trimmed = scanned.trim();
      // Extract P= segment to verify that the scanned component matches expected part
      let scannedPart = '';
      try {
        trimmed.split('|').forEach(function(seg) {
          if (seg.startsWith('P=')) {
            scannedPart = seg.substring(2);
          }
        });
      } catch(err) {
        scannedPart = '';
      }
      if (scannedPart && scannedPart.toLowerCase() !== partName.toLowerCase()) {
        alert('Hai scansionato un componente errato.\nAtteso: ' + partName + '\nRilevato: ' + scannedPart);
        return;
      }
      const payload = {
        assembly_code: assemblyCode,
        component_code: trimmed
      };
      fetch('{{ url_for('api.associate_component') }}', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      }).then(function(response) {
        return response.json();
      }).then(function(data) {
        if (data && data.status === 'ok') {
          alert('Componente associato con successo.');
          // Reload to update counts and readiness
          location.reload();
        } else {
          const msg = (data && data.error) ? data.error : 'Errore di associazione.';
          alert(msg);
        }
      }).catch(function(err) {
        console.error(err);
        alert('Errore di rete durante l\'associazione.');
      });
    });
  });
});
</script>

<!-- Show selected file names for product documentation uploads -->
<script>
// Display selected file names next to each file input in the product build form
document.addEventListener('DOMContentLoaded', function(){
  const form = document.querySelector('form');
  if (!form) return;
  form.addEventListener('change', function(e){
    const target = e.target;
    if (target && target.type === 'file') {
      // Each input is inside a doc-item div; find the nearest .file-name span within the same parent
      const fileNameSpan = target.parentElement.querySelector('.file-name');
      if (fileNameSpan) {
        if (target.files && target.files.length > 0) {
          fileNameSpan.textContent = target.files[0].name;
        } else {
          fileNameSpan.textContent = '';
        }
      }
    }
  });
});
</script>
{% endblock %}